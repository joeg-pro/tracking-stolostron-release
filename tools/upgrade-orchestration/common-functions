# Source me, don't run me.
#
# Some Bash functions for use by upgrade-orchestration scripts.
#
# Blame: joeg-pro
#
# Notes:
#
# - Tested in RHEL 8, not on other Linux or Mac.


temp_file="./tmp.file"

use_ns=""
# Sets a namespace we use henceforth on all OC commands.
set_use_ns() {
   use_ns="$1"
}

# Runs an OC command, applying a target namespace option if defined.
oc_cmd() {
   if [[ -n "$use_ns" ]]; then
      dash_n_arg="-n $use_ns"
   fi
   oc $dash_n_arg "$@"
}

# Applies a manifest passed in via stdin.
function oc_apply () {
   cat > $temp_file
   oc_cmd apply -f $temp_file > /dev/null
   if [[ $? -ne 0 ]]; then
      echo "OC Apply of the following manifest failed:"
      cat $temp_file
      echo "Aborting."
      rm -f $temp_file
      exit 2
   fi
   rm -f $temp_file
}

# Does an OC get and optionally runs the result throuhg a status-checking cmd/function.
get_and_check() {

   kind_and_name="$1"
   status_checker="$2"

   # echo "Getting $kind_and_name"
   oc_cmd get $kind_and_name -o json > $temp_file 2>&1
   rc=$?
   # echo "RC: $rc"
   if [[ $rc -eq 0 ]]; then
      if [[ -n $status_checker ]]; then
         $status_checker $kind_and_name $temp_file
         rc=$?
      fi
   fi
   rm -f "$temp_file"
   return $rc
}

# Gets the default OC project/namespace.
oc_get_default_namespace() {

   msg=$(oc project)
   # Typical msg:
   # Using project "ocm" on server "https://api.jmg-lively-llama.dev01.red-chesterfield.com:6443".

   # Parsing of msgs is often brittle. Try to do this in a way that we can hopefully
   # detect if the msg format has changed and fail if it has.

   r=${msg#Using project \"}
   if [[ "$r" == "$msg" ]]; then
      >&2 echo "Error: Response from oc project is not in expected format."
      >&2 echo "Response: $msg"
      rm -f $temp_file
      exit 2
   fi
   ns=${r%%\"*}
   echo "$ns"
}

# Wauts for a resource to exist and achieve a desired status as determine
# by a status checking funciton or command.  Aborts on timeout.
wait_for_resource_status() {

   kind_and_name="$1"
   status_checker="${2:-true}"
   condition_description="$3"
   wait_time="${4:-10}"

   # echo "kind-and-name: $kind_and_name"
   # echo "status_checker: $status_checker"

   if [[ "$status_checker" != "true" ]]; then
      waiting_for_what="resource $kind_and_name to be $condition_description"
   else
      waiting_for_what="resource $kind_and_name"
   fi

   if [[ $wait_time -gt 120 ]]; then
      wait_limit=$(( (wait_time+9) / 10 ))
      sleep_time="10s"
   elif [[ $wait_time -gt 60 ]]; then
      wait_limit=$(( (wait_time+4) / 5 ))
      sleep_time="5s"
   elif [[ $wait_time -gt 20 ]]; then
      wait_limit=$(( (wait_time+1) / 2 ))
      sleep_time="2s"
   else
      wait_limit=$wait_time
      sleep_time="1s"
   fi

   wait_ct=0
   first_time=1
   get_and_check $kind_and_name $status_checker
   while [[ $? -ne 0 && ( $wait_ct -le $wait_limit ) ]]; do
      if [[ $first_time -eq 1 ]]; then
         echo "Waiting for $waiting_for_what."
         first_time=0
      fi
      wait_ct=$(( $wait_ct + 1 ))
      sleep $sleep_time
      get_and_check $kind_and_name $status_checker
   done
   if [[ $? -ne 0 ]]; then
      echo "Error: Timeout waiting for $waiting_for_what."
      echo "Aborting."
      exit 2
   fi
}

# Wait for a resource to actually exist.  Aborts on timeout.
function wait_for_resource() {

   kind_and_name="$1"
   wait_limit="${2:-10}"

   wait_for_resource_status "$kind_and_name" "true" "not-used" "$wait_limit"
}

# --- Status Get and Test Functions ---

# Get subscription status

get_subscription_status() {

   resource_json_file="$1"

   st=$(jq -r ".status.state" "$resource_json_file")
   echo $st
}


# Status checking function for a subscription reaching Upgrade-Pending state.
subscription_is_upgrade_pending() {

   kind_and_name="$1"
   resource_json_file="$2"

   st=$(get_subscription_status "$resource_json_file")
   # echo "Debug: Subscription $kind_and_name status is: $st"
   [[ $st == "UpgradePending" ]]
   return $?
}

subscription_is_upgrade_available() {

   kind_and_name="$1"
   resource_json_file="$2"

   st=$(get_subscription_status "$resource_json_file")
   # echo "Debug: .Subscription $kind_and_name status is: $st"
   [[ $st == "UpgradeAvailable" ]]
   return $?
}

# Status checking function for an install-plan reaching complete state.
install_plan_is_complete() {

   kind_and_name="$1"
   resource_json_file="$2"

   st=$(jq -r ".status.phase" $resource_json_file)
   [[ $st == "Complete" ]]
   return $?
}

# Status checking function for CSV reaching (installed) Succeeeded state.
csv_install_is_successful() {

   kind_and_name="$1"
   resource_json_file="$2"
   st=$(jq -r ".status.phase" $resource_json_file)
   [[ $st == "Succeeded" ]]
   return $?
}


# --- Higher Level Functions ---

get_subscription_into_temp_file() {
   oc_cmd get $subscription_kind_and_name -o json > $temp_file
   if [[ $? -ne 0 ]]; then
      if [[ -z "$use_ns" ]]; then
         what_ns="default project namespace"
      else
         what_ns="namespace $use_ns"
      fi
      >&2 echo "Could not get subscription $subscription_kind_and_name in $what_ns."
      exit 2
   fi
}

# Find the pending install plan for a subscription and approve it.
find_and_approve_install_plan() {
   # Side effect: sets the_install_plan

   local st

   subscription_kind_and_name="$1"

   get_subscription_into_temp_file $subscription_kind_and_name
   st=$(get_subscription_status "$temp_file")

   if [[ "$st" == "AtLatestKnown" ]]; then
      >&2 echo "Error: No install/upgrade is available or pending."
      rm -f $temp_file
      exit 2
   fi

   pending_wait_limit=600

   if [[ "$st" == "UpgradeAvailable" ]]; then
      echo "An install/upgrade is available, wiating for it to become pending."
      start=$(date "+%s")
      wait_for_resource_status $subscription_kind_and_name subscription_is_upgrade_pending "Upgrade-Pending" $pending_wait_limit
      now=$(date "+%s")
      elap=$((now - start))
      echo "Delay until upgrade-pending state was $elap seconds."

      # Refresh temp file since wait_for deleted it.
      get_subscription_into_temp_file $subscription_kind_and_name
      st=$(get_subscription_status "$temp_file")
   fi

   if [[ "$st" != "UpgradePending" ]]; then
      >&2 echo "Unrecognized current status for Subscription: $st."
      exit 2
   fi

   current_csv=$(jq -r ".status.currentCSV" $temp_file)
   echo "An install/upgrade is pending. Next CSV to be applied: $current_csv."

   ip_ns=$(jq -r ".status.installPlanRef.namespace" $temp_file)
   ip_kind=$(jq -r ".status.installPlanRef.kind" $temp_file)
   ip_name=$(jq -r ".status.installPlanRef.name" $temp_file)
   the_install_plan="$ip_kind/$ip_name"

   echo "Peding install plan: $the_install_plan"

   oc_cmd patch $the_install_plan --type merge --patch '{"spec": {"approved": true}}' > /dev/null
   echo "Install Plan ($ip_name) is now approved."
}

# Wauts for an install plan to reach Complete status.
wait_for_install_plan_complete() {

   install_plan_kind_and_name="$1"
   wait_limit="${2:-480}"
   wait_for_resource_status $install_plan_kind_and_name install_plan_is_complete "Complete" $wait_limit
}

# Waits for the CSV listed as the "instaleldCVS" in a subscription to reach Succeeded state.
wait_for_csv_to_succeed() {

   subscription_kind_and_name="$1"
   wait_limit="${2:-480}"

   get_subscription_into_temp_file $subscription_kind_and_name

   installed_csv=$(jq -r ".status.installedCSV" $temp_file)
   the_installed_csv="ClusterServiceVErsion/$installed_csv"

   oc_cmd get $the_installed_csv -o json > $temp_file
   if [[ $? -ne 0 ]]; then
      >&2 echo "Could not get CSV $the_installed_csv."
      exit 2
   fi

   vers=$(jq -r ".spec.version" $temp_file)
   st=$(jq -r ".status.phase" $temp_file)

   if [[ "$st" != "Succeeded" ]]; then
      echo "Operator installation is not finished yet."
      msg=$(jq -r ".status.message" $temp_file)
      echo "Currently: $msg"

      echo "Waiting for operator installation to finish."

      wait_for_resource_status $the_installed_csv csv_install_is_successful "Successful" 60
   fi
   echo "Operator is now installed. Version: $vers."

}

# Reports ont he status of a subscription at the end of an install/upgrade.
report_on_subscritpion_ending_status() {

   subscription_kind_and_name="$1"

   get_subscription_into_temp_file $subscription_kind_and_name

   st=$(jq -r ".status.state" $temp_file)
   installed_csv=$(jq -r ".status.installedCSV" $temp_file)
   current_csv=$(jq -r ".status.currentCSV" $temp_file)

   if [[ "$st" == "AtLatestKnown" ]]; then
      echo "Subscription is now up-to-date."
   elif [[ "$st" == "UpgradeAvailable" ]]; then
      echo "Upgrade is available.  Next CSV not yet known."
   elif [[ "$st" == "UpgradePending" ]]; then
      echo "Upgrade is pending.  Next CSV: $current_csv."
   else
      echo "Unrecognized ending status for Subscription: $st."
   fi
}

